# 구조적 의사결정 목록

## 개요

### 목적
명세된 구조 설계서(architecture.md)에서 구조적 의사결정을 식별하고 분석하여, 설계된 구조가 어떤 설계 결정에 기반하고 있는지, 각 결정이 어떤 품질 요구사항에 영향을 미치는지를 명확히 문서화합니다.

### 분석 범위
- **분석 대상**: architecture.md의 2장(요구사항), 3장(시스템 구조), 4장(모듈 구조)
- **제외**: 부록은 참고하지 않음
- **식별 기준**: 
  - 대안을 생각할 수 있는 설계 결정
  - 중요한 품질 요구사항(NFR 또는 QA)에 영향을 미치는 설계 결정

## 요구사항 요약

### 기능적 요구사항
Count 통합 관리 시스템은 다음 5개의 주요 Use Case를 제공합니다:
- **UC-001-Count 저장**: 외부 서비스가 Count 값을 저장하거나 증가/감소시킵니다.
- **UC-002-Count 조회**: 외부 서비스나 관리자가 저장된 Count 데이터를 조회합니다.
- **UC-003-Count 관리**: 관리자가 웹 UI를 통해 Count 데이터를 생성, 수정, 삭제하는 통합 관리 기능을 수행합니다.
- **UC-004-Count 분석**: 관리자가 Count 데이터에 대한 다양한 분석 기능(트렌드 분석, 비교 분석, 예측 분석 등)을 수행합니다.
- **UC-005-Count 모니터링**: 관리자가 대시보드를 통해 Count 데이터를 모니터링하고 시각화된 정보를 확인합니다.

### 품질 요구사항

#### 비기능적 요구사항 (NFR)
- **NFR-001-Count-저장-응답-시간**: 외부 서비스가 Count 값을 저장하거나 증가/감소시킬 때의 응답 시간, 허용치: `[Count 저장 응답 시간] < 100ms`
- **NFR-002-Count-조회-응답-시간**: 외부 서비스나 관리자가 Count 값을 조회할 때의 응답 시간, 허용치: `[Count 조회 응답 시간] < 100ms`
- **NFR-003-동시-요청-처리-능력**: 여러 외부 서비스가 동시에 Count 저장/조회 요청을 보낼 때 처리할 수 있는 요청 수, 허용치: `[동시 요청 처리량] >= 1000 RPS`
- **NFR-004-대시보드-로딩-시간**: 관리자가 대시보드를 열었을 때 초기 데이터를 로딩하는 시간, 허용치: `[대시보드 로딩 시간] < 3초`

#### 품질 속성 (QA)
- **QA-001-Count-저장-응답-시간-최소화**: 우선순위 1 (최우선)
- **QA-002-Count-조회-응답-시간-최소화**: 우선순위 2
- **QA-003-Count-저장-서비스-독립성-최대화**: 우선순위 3
- **QA-004-Count-조회-서비스-독립성-최대화**: 우선순위 4
- **QA-005-분석-기능-추가-용이성-최대화**: 우선순위 5
- **QA-006-대시보드-기능-추가-용이성-최대화**: 우선순위 6
- **QA-007-UI-변경-용이성-최대화**: 우선순위 7
- **QA-008-Count-관리-서비스-독립성-최대화**: 우선순위 8
- **QA-009-Count-분석-서비스-독립성-최대화**: 우선순위 9
- **QA-010-Count-모니터링-서비스-독립성-최대화**: 우선순위 10
- **QA-011-대시보드-갱신-시간-최소화**: 우선순위 11
- **QA-012-입력-오류-복원-용이성-최대화**: 우선순위 12

## 구조적 의사결정 목록

### AD-001: Count 저장/조회 서비스 분할

- **의사결정 내용**: Count 저장 기능과 조회 기능을 별도의 마이크로서비스(count-write-service, count-read-service)로 분할하여 독립적으로 배포 및 스케일링 가능하도록 설계
- **관련 구조**: 3장 3.1 컴포넌트 명세의 Count 저장 서비스 및 Count 조회 서비스
- **대안**: 
  - **대안 1**: Count 저장/조회 서비스 통합 - 단일 서비스로 통합하여 단순한 구조 유지
- **영향받는 품질 요구사항**:
  - **QA-001 (Count 저장 응답 시간 최소화)**: (+) - 서비스 분할로 인한 네트워크 오버헤드가 있지만, 독립적 성능 최적화로 전체적으로 개선
  - **QA-002 (Count 조회 응답 시간 최소화)**: (++) - 독립적 최적화 및 읽기 전용 복제본 활용으로 조회 성능 크게 향상
  - **QA-003 (Count 저장 서비스 독립성 최대화)**: (++) - 서비스 분할로 독립적인 배포, 스케일링, 운영 가능하여 독립성 크게 향상
  - **QA-004 (Count 조회 서비스 독립성 최대화)**: (++) - 서비스 분할로 독립적인 배포, 스케일링, 운영 가능하여 독립성 크게 향상
  - **NFR-003 (동시 요청 처리 능력)**: (++) - 독립적 확장 가능하여 처리량 크게 향상
- **트레이드오프**: 복잡도 증가를 감수하고 성능, 확장성, 서비스 독립성을 크게 개선

### AD-002: Count 관리/분석/모니터링 서비스 분할

- **의사결정 내용**: Count 관리, 분석, 모니터링 기능을 각각 별도의 마이크로서비스(count-management-service, count-analysis-service, dashboard-provision-service, dashboard-update-service)로 분할
- **관련 구조**: 3장 3.1 컴포넌트 명세의 Count 관리 서비스, Count 분석 서비스, 대시보드 제공 서비스, 대시보드 갱신 서비스
- **대안**: 
  - **대안 1**: 관리자 기능 통합 서비스 - 관리자 관련 모든 기능을 단일 서비스로 통합
- **영향받는 품질 요구사항**:
  - **QA-008 (Count 관리 서비스 독립성 최대화)**: (++) - 서비스 분할로 독립적인 배포, 스케일링, 운영 가능하여 독립성 크게 향상
  - **QA-009 (Count 분석 서비스 독립성 최대화)**: (++) - 서비스 분할로 독립적인 배포, 스케일링, 운영 가능하여 독립성 크게 향상
  - **QA-010 (Count 모니터링 서비스 독립성 최대화)**: (++) - 서비스 분할로 독립적인 배포, 스케일링, 운영 가능하여 독립성 크게 향상
  - **QA-005 (분석 기능 추가 용이성 최대화)**: (+) - 서비스 분할로 분석 기능 추가 시 영향 범위 최소화
  - **QA-006 (대시보드 기능 추가 용이성 최대화)**: (+) - 서비스 분할로 대시보드 기능 추가 시 영향 범위 최소화
- **트레이드오프**: 복잡도 증가를 감수하고 서비스 독립성과 변경 용이성을 크게 개선

### AD-003: Database per Service 패턴 적용

- **의사결정 내용**: 각 서비스가 독립적인 데이터베이스를 사용하도록 설계 (CountInfoDB, CountValueDB, DashboardConfigDB 분리)
- **관련 구조**: 3장 3.1 컴포넌트 명세의 데이터베이스 및 인프라 컴포넌트
- **대안**: 
  - **대안 1**: 단일 데이터베이스 공유 - 모든 서비스가 하나의 데이터베이스를 공유
- **영향받는 품질 요구사항**:
  - **QA-003 (Count 저장 서비스 독립성 최대화)**: (++) - 데이터베이스 분리로 서비스 간 데이터 의존성 제거, 독립성 크게 향상
  - **QA-004 (Count 조회 서비스 독립성 최대화)**: (++) - 데이터베이스 분리로 서비스 간 데이터 의존성 제거, 독립성 크게 향상
  - **QA-008 (Count 관리 서비스 독립성 최대화)**: (++) - 데이터베이스 분리로 서비스 간 데이터 의존성 제거, 독립성 크게 향상
  - **QA-009 (Count 분석 서비스 독립성 최대화)**: (++) - 데이터베이스 분리로 서비스 간 데이터 의존성 제거, 독립성 크게 향상
  - **QA-010 (Count 모니터링 서비스 독립성 최대화)**: (++) - 데이터베이스 분리로 서비스 간 데이터 의존성 제거, 독립성 크게 향상
- **트레이드오프**: 데이터 일관성 관리 복잡도 증가를 감수하고 서비스 독립성을 크게 개선

### AD-004: CountValueDB Read Replica 분리

- **의사결정 내용**: CountValueDB의 읽기 전용 복제본을 분리하여 읽기 부하를 분산하고 조회 성능을 향상
- **관련 구조**: 3장 3.1 컴포넌트 명세의 CountValueDB Read Replica
- **대안**: 
  - **대안 1**: 단일 CountValueDB 사용 - 읽기와 쓰기가 동일한 데이터베이스 사용
- **영향받는 품질 요구사항**:
  - **QA-002 (Count 조회 응답 시간 최소화)**: (++) - 읽기 전용 복제본으로 조회 부하 분산 및 성능 향상
  - **NFR-002 (Count 조회 응답 시간)**: (++) - 읽기 전용 복제본으로 조회 부하 분산 및 성능 향상
  - **NFR-003 (동시 요청 처리 능력)**: (++) - 읽기 전용 복제본을 통한 수평 확장으로 처리량 크게 향상
- **트레이드오프**: 데이터 복제 지연 가능성을 감수하고 조회 성능과 처리량을 크게 개선

### AD-005: 캐싱 전술 적용

- **의사결정 내용**: CountInfoDB 캐싱, CountValueDB 캐싱, 조회 결과 캐싱, 대시보드 데이터 캐싱을 적용하여 응답 시간을 단축
- **관련 구조**: 3장 3.1 컴포넌트 명세의 Redis 캐시, 3장 3.2 동작 명세의 캐싱 사용
- **대안**: 
  - **대안 1**: 캐싱 미적용 - 모든 데이터를 데이터베이스에서 직접 조회
- **영향받는 품질 요구사항**:
  - **QA-001 (Count 저장 응답 시간 최소화)**: (++) - CountInfoDB 조회 지연 제거로 저장 응답 시간 크게 단축
  - **QA-002 (Count 조회 응답 시간 최소화)**: (++) - CountInfoDB 및 CountValueDB 조회 지연 제거로 조회 응답 시간 크게 단축
  - **NFR-001 (Count 저장 응답 시간)**: (++) - CountInfoDB 캐싱으로 저장 응답 시간 크게 단축
  - **NFR-002 (Count 조회 응답 시간)**: (++) - 캐싱으로 조회 응답 시간 크게 단축
  - **NFR-004 (대시보드 로딩 시간)**: (++) - 대시보드 데이터 캐싱으로 로딩 시간 크게 단축
- **트레이드오프**: 캐시 일관성 관리 복잡도 증가를 감수하고 응답 시간을 크게 개선

### AD-006: Write-Behind 캐싱 전술 적용

- **의사결정 내용**: CountValueDB에 대한 Write-Behind 캐싱을 적용하여 비동기 쓰기로 응답 시간을 단축
- **관련 구조**: 3장 3.2 동작 명세의 UC-001 Count 저장에서 Write-Behind 캐싱 사용
- **대안**: 
  - **대안 1**: Write-Through 캐싱 - 동기 쓰기로 즉시 일관성 보장
  - **대안 2**: Write-Around 캐싱 - 캐시를 우회하여 직접 데이터베이스에 쓰기
- **영향받는 품질 요구사항**:
  - **QA-001 (Count 저장 응답 시간 최소화)**: (++) - 비동기 쓰기로 응답 시간 크게 단축
  - **NFR-001 (Count 저장 응답 시간)**: (++) - 비동기 쓰기로 응답 시간 크게 단축
  - **NFR-003 (동시 요청 처리 능력)**: (++) - 비동기 처리로 처리량 크게 향상
- **트레이드오프**: 즉시 일관성 저하(Eventual Consistency)를 감수하고 응답 시간과 처리량을 크게 개선

### AD-007: Atomic 증가/감소 연산 사용

- **의사결정 내용**: CountValueDB에서 Redis의 네이티브 Atomic 증가/감소 연산(INCR, DECR)을 사용하여 읽기-수정-쓰기 패턴을 제거
- **관련 구조**: 3장 3.2 동작 명세의 UC-001 Count 저장에서 Atomic 연산 사용
- **대안**: 
  - **대안 1**: 읽기-수정-쓰기 패턴 - 데이터를 읽고 수정한 후 다시 쓰기
- **영향받는 품질 요구사항**:
  - **QA-001 (Count 저장 응답 시간 최소화)**: (++) - 읽기-수정-쓰기 패턴 제거로 응답 시간 크게 단축
  - **NFR-001 (Count 저장 응답 시간)**: (++) - 읽기-수정-쓰기 패턴 제거로 응답 시간 크게 단축
  - **NFR-003 (동시 요청 처리 능력)**: (++) - 동시성 제어 오버헤드 감소로 처리량 크게 향상
- **트레이드오프**: 특정 데이터베이스 기능에 의존성을 가지지만 성능과 처리량을 크게 개선

### AD-008: 이벤트 기반 통신 적용

- **의사결정 내용**: Kafka 메시징을 사용하여 이벤트 기반 통신을 적용하고, 변경 이벤트를 발행하여 대시보드 실시간 갱신 지원
- **관련 구조**: 3장 3.1 컴포넌트 명세의 Kafka 메시징, 3장 3.2 동작 명세의 이벤트 발행/구독
- **대안**: 
  - **대안 1**: 동기 통신 - REST API를 통한 직접 호출
  - **대안 2**: 폴링 방식 - 주기적으로 데이터를 조회하여 변경 감지
- **영향받는 품질 요구사항**:
  - **QA-011 (대시보드 갱신 시간 최소화)**: (++) - 폴링 방식 대신 이벤트 기반으로 갱신 시간 크게 단축
  - **NFR-003 (동시 요청 처리 능력)**: (++) - 비동기 메시징으로 처리량 크게 향상
- **트레이드오프**: 메시징 시스템 운영 복잡도 증가를 감수하고 실시간 갱신 성능과 처리량을 크게 개선

### AD-009: SSE 실시간 통신 적용

- **의사결정 내용**: 대시보드 갱신 서비스에서 Server-Sent Events(SSE)를 사용하여 실시간 갱신 제공
- **관련 구조**: 3장 3.1 컴포넌트 명세의 대시보드 갱신 서비스, 3장 3.2 동작 명세의 UC-005 Count 모니터링
- **대안**: 
  - **대안 1**: WebSocket - 양방향 통신 지원
  - **대안 2**: 폴링 방식 - 주기적으로 HTTP 요청으로 데이터 조회
- **영향받는 품질 요구사항**:
  - **QA-011 (대시보드 갱신 시간 최소화)**: (+) - 단방향 통신으로 실시간 갱신 성능 향상
  - **NFR-003 (동시 요청 처리 능력)**: (+) - 연결 오버헤드 낮음으로 동시성 처리에 유리
- **트레이드오프**: 양방향 통신 기능을 포기하고 단순성과 동시성 처리 능력을 개선

### AD-010: 대시보드 제공/갱신 서비스 분리

- **의사결정 내용**: 대시보드 UI 제공 기능과 실시간 갱신 기능을 별도의 서비스(dashboard-provision-service, dashboard-update-service)로 분리
- **관련 구조**: 3장 3.1 컴포넌트 명세의 대시보드 제공 서비스 및 대시보드 갱신 서비스
- **대안**: 
  - **대안 1**: 대시보드 서비스 통합 - UI 제공과 갱신 기능을 단일 서비스로 통합
- **영향받는 품질 요구사항**:
  - **QA-010 (Count 모니터링 서비스 독립성 최대화)**: (++) - 서비스 분리로 독립적인 배포, 스케일링, 운영 가능하여 독립성 크게 향상
  - **QA-006 (대시보드 기능 추가 용이성 최대화)**: (+) - 서비스 분리로 기능 추가 시 영향 범위 최소화
  - **NFR-004 (대시보드 로딩 시간)**: (+) - 서비스 분리로 독립적 최적화 가능하여 로딩 시간 개선
  - **QA-011 (대시보드 갱신 시간 최소화)**: (+) - 서비스 분리로 독립적 최적화 가능하여 갱신 시간 개선
- **트레이드오프**: 복잡도 증가를 감수하고 서비스 독립성과 변경 용이성을 크게 개선

### AD-011: 도메인별 공통 모듈 구조 적용

- **의사결정 내용**: CountInfo와 CountValue 도메인별로 공통 모듈(common.count-info, common.count-value)을 구성하여 도메인별 로직을 캡슐화하고 재사용성 향상
- **관련 구조**: 4장 4.1 모듈 명세의 공통 모듈 레이어
- **대안**: 
  - **대안 1**: 서비스별 독립 모듈 - 각 서비스가 독립적으로 필요한 모듈 구현
  - **대안 2**: 계층별 공통 모듈 - Infra, Logic, API 레이어별로 공통 모듈 구성
- **영향받는 품질 요구사항**:
  - **QA-005 (분석 기능 추가 용이성 최대화)**: (++) - 도메인별 공통 모듈로 분석 기능 추가 시 영향 범위 크게 제한. CountValue 분석 로직이 `common.count-value.logic.analysis`에 집중되어 분석 기능 추가 용이
  - **QA-011 (데이터베이스 변경 용이성)**: (++) - CountValueDB 관련 모든 로직(infra + logic)이 `common.count-value` 모듈에 완전히 캡슐화되어 데이터베이스 변경 시 영향 범위 크게 제한
- **트레이드오프**: 공통 모듈 의존성 관리 복잡도 증가를 감수하고 변경 용이성을 크게 개선

### AD-012: 리포지토리 패턴 적용

- **의사결정 내용**: 데이터베이스 접근을 Repository 인터페이스와 구현체로 분리하여 데이터베이스 변경 시 영향 범위를 제한
- **관련 구조**: 4장 4.1 모듈 명세의 CountInfoRepository, CountValueRepository
- **대안**: 
  - **대안 1**: 직접 데이터베이스 접근 - Service에서 직접 데이터베이스 접근
- **영향받는 품질 요구사항**:
  - **QA-011 (데이터베이스 변경 용이성)**: (++) - 리포지토리 패턴으로 데이터베이스 변경 시 Repository 구현체만 수정하면 되므로 영향 범위 크게 제한
- **트레이드오프**: 추상화 계층 추가로 인한 복잡도 증가를 감수하고 데이터베이스 변경 용이성을 크게 개선

### AD-013: AnalysisStrategy 인터페이스 추상화

- **의사결정 내용**: 분석 기능을 AnalysisStrategy 인터페이스로 추상화하고 전략 패턴을 적용하여 새로운 분석 기능 추가 시 기존 코드 수정 불필요
- **관련 구조**: 4장 4.1 모듈 명세의 AnalysisStrategy 인터페이스 및 구현체
- **대안**: 
  - **대안 1**: 직접 구현 - CountAnalyzer에서 각 분석 유형을 직접 처리
- **영향받는 품질 요구사항**:
  - **QA-005 (분석 기능 추가 용이성 최대화)**: (++) - 인터페이스 추상화로 분석 기능 추가 시 CountAnalyzer 수정 불필요, 영향 범위 크게 제한
- **트레이드오프**: 인터페이스 추상화로 인한 복잡도 증가를 감수하고 분석 기능 추가 용이성을 크게 개선

### AD-014: API 어댑터 계층 분리

- **의사결정 내용**: REST API 요청을 비즈니스 로직으로 변환하는 어댑터 계층을 분리하여 프로토콜 변경 시 영향 범위를 제한
- **관련 구조**: 4장 4.1 모듈 명세의 CountWriteAdapter, CountReadAdapter
- **대안**: 
  - **대안 1**: Controller에서 직접 처리 - Controller에서 비즈니스 로직까지 직접 처리
- **영향받는 품질 요구사항**:
  - **QA-007 (UI 변경 용이성 최대화)**: (+) - API 어댑터 계층 분리로 프로토콜 변경 시 어댑터만 수정하면 되므로 영향 범위 제한
- **트레이드오프**: 어댑터 계층 추가로 인한 복잡도 증가를 감수하고 프로토콜 변경 용이성을 개선

### AD-015: UI와 API 계층 분리

- **의사결정 내용**: 관리자 UI와 외부 서비스 API를 서로 다른 서비스로 분리하여 UI 변경이 API에 영향을 미치지 않도록 설계
- **관련 구조**: 4장 4.1 모듈 명세의 서비스별 레이어 (ui.management, ui.analysis, ui.dashboard vs api.write, api.read)
- **대안**: 
  - **대안 1**: 통합 서비스 - UI와 API를 단일 서비스로 통합
- **영향받는 품질 요구사항**:
  - **QA-007 (UI 변경 용이성 최대화)**: (++) - UI와 API 계층 분리로 UI 변경 시 API에 영향 없음, 영향 범위 크게 제한
  - **QA-003 (Count 저장 서비스 독립성 최대화)**: (+) - UI와 API 분리로 서비스 독립성 향상
  - **QA-004 (Count 조회 서비스 독립성 최대화)**: (+) - UI와 API 분리로 서비스 독립성 향상
- **트레이드오프**: 서비스 수 증가로 인한 복잡도 증가를 감수하고 UI 변경 용이성과 서비스 독립성을 크게 개선
